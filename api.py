#                                  Apache License
#                            Version 2.0, January 2004
#                         http://www.apache.org/licenses/

#    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

#    1. Definitions.

#       "License" shall mean the terms and conditions for use, reproduction,
#       and distribution as defined by Sections 1 through 9 of this document.

#       "Licensor" shall mean the copyright owner or entity authorized by
#       the copyright owner that is granting the License.

#       "Legal Entity" shall mean the union of the acting entity and all
#       other entities that control, are controlled by, or are under common
#       control with that entity. For the purposes of this definition,
#       "control" means (i) the power, direct or indirect, to cause the
#       direction or management of such entity, whether by contract or
#       otherwise, or (ii) ownership of fifty percent (50%) or more of the
#       outstanding shares, or (iii) beneficial ownership of such entity.

#       "You" (or "Your") shall mean an individual or Legal Entity
#       exercising permissions granted by this License.

#       "Source" form shall mean the preferred form for making modifications,
#       including but not limited to software source code, documentation
#       source, and configuration files.

#       "Object" form shall mean any form resulting from mechanical
#       transformation or translation of a Source form, including but
#       not limited to compiled object code, generated documentation,
#       and conversions to other media types.

#       "Work" shall mean the work of authorship, whether in Source or
#       Object form, made available under the License, as indicated by a
#       copyright notice that is included in or attached to the work
#       (an example is provided in the Appendix below).

#       "Derivative Works" shall mean any work, whether in Source or Object
#       form, that is based on (or derived from) the Work and for which the
#       editorial revisions, annotations, elaborations, or other modifications
#       represent, as a whole, an original work of authorship. For the purposes
#       of this License, Derivative Works shall not include works that remain
#       separable from, or merely link (or bind by name) to the interfaces of,
#       the Work and Derivative Works thereof.

#       "Contribution" shall mean any work of authorship, including
#       the original version of the Work and any modifications or additions
#       to that Work or Derivative Works thereof, that is intentionally
#       submitted to Licensor for inclusion in the Work by the copyright owner
#       or by an individual or Legal Entity authorized to submit on behalf of
#       the copyright owner. For the purposes of this definition, "submitted"
#       means any form of electronic, verbal, or written communication sent
#       to the Licensor or its representatives, including but not limited to
#       communication on electronic mailing lists, source code control systems,
#       and issue tracking systems that are managed by, or on behalf of, the
#       Licensor for the purpose of discussing and improving the Work, but
#       excluding communication that is conspicuously marked or otherwise
#       designated in writing by the copyright owner as "Not a Contribution."

#       "Contributor" shall mean Licensor and any individual or Legal Entity
#       on behalf of whom a Contribution has been received by Licensor and
#       subsequently incorporated within the Work.

#    2. Grant of Copyright License. Subject to the terms and conditions of
#       this License, each Contributor hereby grants to You a perpetual,
#       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#       copyright license to reproduce, prepare Derivative Works of,
#       publicly display, publicly perform, sublicense, and distribute the
#       Work and such Derivative Works in Source or Object form.

#    3. Grant of Patent License. Subject to the terms and conditions of
#       this License, each Contributor hereby grants to You a perpetual,
#       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#       (except as stated in this section) patent license to make, have made,
#       use, offer to sell, sell, import, and otherwise transfer the Work,
#       where such license applies only to those patent claims licensable
#       by such Contributor that are necessarily infringed by their
#       Contribution(s) alone or by combination of their Contribution(s)
#       with the Work to which such Contribution(s) was submitted. If You
#       institute patent litigation against any entity (including a
#       cross-claim or counterclaim in a lawsuit) alleging that the Work
#       or a Contribution incorporated within the Work constitutes direct
#       or contributory patent infringement, then any patent licenses
#       granted to You under this License for that Work shall terminate
#       as of the date such litigation is filed.

#    4. Redistribution. You may reproduce and distribute copies of the
#       Work or Derivative Works thereof in any medium, with or without
#       modifications, and in Source or Object form, provided that You
#       meet the following conditions:

#       (a) You must give any other recipients of the Work or
#           Derivative Works a copy of this License; and

#       (b) You must cause any modified files to carry prominent notices
#           stating that You changed the files; and

#       (c) You must retain, in the Source form of any Derivative Works
#           that You distribute, all copyright, patent, trademark, and
#           attribution notices from the Source form of the Work,
#           excluding those notices that do not pertain to any part of
#           the Derivative Works; and

#       (d) If the Work includes a "NOTICE" text file as part of its
#           distribution, then any Derivative Works that You distribute must
#           include a readable copy of the attribution notices contained
#           within such NOTICE file, excluding those notices that do not
#           pertain to any part of the Derivative Works, in at least one
#           of the following places: within a NOTICE text file distributed
#           as part of the Derivative Works; within the Source form or
#           documentation, if provided along with the Derivative Works; or,
#           within a display generated by the Derivative Works, if and
#           wherever such third-party notices normally appear. The contents
#           of the NOTICE file are for informational purposes only and
#           do not modify the License. You may add Your own attribution
#           notices within Derivative Works that You distribute, alongside
#           or as an addendum to the NOTICE text from the Work, provided
#           that such additional attribution notices cannot be construed
#           as modifying the License.

#       You may add Your own copyright statement to Your modifications and
#       may provide additional or different license terms and conditions
#       for use, reproduction, or distribution of Your modifications, or
#       for any such Derivative Works as a whole, provided Your use,
#       reproduction, and distribution of the Work otherwise complies with
#       the conditions stated in this License.

#    5. Submission of Contributions. Unless You explicitly state otherwise,
#       any Contribution intentionally submitted for inclusion in the Work
#       by You to the Licensor shall be under the terms and conditions of
#       this License, without any additional terms or conditions.
#       Notwithstanding the above, nothing herein shall supersede or modify
#       the terms of any separate license agreement you may have executed
#       with Licensor regarding such Contributions.

#    6. Trademarks. This License does not grant permission to use the trade
#       names, trademarks, service marks, or product names of the Licensor,
#       except as required for reasonable and customary use in describing the
#       origin of the Work and reproducing the content of the NOTICE file.

#    7. Disclaimer of Warranty. Unless required by applicable law or
#       agreed to in writing, Licensor provides the Work (and each
#       Contributor provides its Contributions) on an "AS IS" BASIS,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
#       implied, including, without limitation, any warranties or conditions
#       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
#       PARTICULAR PURPOSE. You are solely responsible for determining the
#       appropriateness of using or redistributing the Work and assume any
#       risks associated with Your exercise of permissions under this License.

#    8. Limitation of Liability. In no event and under no legal theory,
#       whether in tort (including negligence), contract, or otherwise,
#       unless required by applicable law (such as deliberate and grossly
#       negligent acts) or agreed to in writing, shall any Contributor be
#       liable to You for damages, including any direct, indirect, special,
#       incidental, or consequential damages of any character arising as a
#       result of this License or out of the use or inability to use the
#       Work (including but not limited to damages for loss of goodwill,
#       work stoppage, computer failure or malfunction, or any and all
#       other commercial damages or losses), even if such Contributor
#       has been advised of the possibility of such damages.

#    9. Accepting Warranty or Additional Liability. While redistributing
#       the Work or Derivative Works thereof, You may choose to offer,
#       and charge a fee for, acceptance of support, warranty, indemnity,
#       or other liability obligations and/or rights consistent with this
#       License. However, in accepting such obligations, You may act only
#       on Your own behalf and on Your sole responsibility, not on behalf
#       of any other Contributor, and only if You agree to indemnify,
#       defend, and hold each Contributor harmless for any liability
#       incurred by, or claims asserted against, such Contributor by reason
#       of your accepting any such warranty or additional liability.

#    END OF TERMS AND CONDITIONS

#    APPENDIX: How to apply the Apache License to your work.

#       To apply the Apache License to your work, attach the following
#       boilerplate notice, with the fields enclosed by brackets "[]"
#       replaced with your own identifying information. (Don't include
#       the brackets!)  The text should be enclosed in the appropriate
#       comment syntax for the file format. We also recommend that a
#       file or class name and description of purpose be included on the
#       same "printed page" as the copyright notice for easier
#       identification within third-party archives.

#    Copyright 2022 Xel Lu

#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at

#        http://www.apache.org/licenses/LICENSE-2.0

#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

import hashlib
import json
import os
import random
import string
import threading
import time
import asyncio
import uuid as uuidgen
import zipfile
from datetime import datetime
import localstorage.scripts as scriptbase

import flask
from colorama import Fore
from flask import (Flask, abort, make_response, redirect, render_template,
                   request, send_file, send_from_directory)
import discord
from discord.ext import commands
from discord.ext import *
import requests
from discord_webhook import DiscordWebhook, DiscordEmbed

NULL = "[NULL]"
invis_char = "​"
hide_text = "||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||"
lockdown = False
profanities = open("files/profanities.txt", "r").read().splitlines()

class user:
    def __init__(self): #, username: str, token: str, password: str, posts: list, uid: int, uuid: str, discord: int, discord_access_token: str, domain: str, hidden_url: bool, embed: dict, profile: dict, discord_webhook: dict):
        """
        Xello.Blue User Object\n\n
        
        :username: (string) the name that will show up everywhere\n
        :token: (string) the authentication token for the website\n
        :password: (string/hash) the password\n
        :posts: (list) a list of uploaded files\n
        :uid: (integer) the id of the user as an int\n
        :uuid: (string/uuid) the id of the user as UUID\n
        :discord: (string) the access token for the account if the account is connected\n
        :domain: domain that will copy to clipboard upon upload\n
        :hidden_url: (boolean) will hide the url from discord if toggled\n
        :embed: (dictionary) embed settings\n
        :profile: (dictionary) profile settings\n
        :permissionlvl: (int) indicates the permissions the user has (0 = Default, 1000 = All perms)\n
        :badges: (list) badges that will be visible on the profile\n
        :_2fa: (dictionary) 2 factor authentication status\n
        :invite_meta: (dictionary) invite data such as who invited the user\n
        :invite_created: (list) invites the user has\n
        """
        
        self.username = ""
        self.token = ""
        self.password = ""
        self.posts = []
        self.uid = 0
        self.uuid = ""
        self.discord = {"id": 0, "discriminator": "", "username": "", "email": ""}
        self.domain = {"domain": "xello.blue", "subdomain": "i.", "random": False, "randomDomains": ["xello.blue", "ketamine.top", "drifty.wtf"]}
        self.hidden_url = False
        self.url_settings = {"emojiUrl": False}
        self.embed = {"enabled": False, "color": "#A89FFF", "title": "XelloBlue", "description": "Uploaded by %user%"}
        self.profile = {"bio": "", "show_discord": True, "font": "Rubik", "theme": "dark"}
        self.permissionlvl = 0
        self.badges = []
        self._2fa = {"enabled": False, "active": False, "code": ""}
        self.invite_meta = {"code": None, "createdBy": None, "usedBy": "@me"}
        self.invite_created = []
        self.sharify_invite = "FAILED TO GENERATE"
        
    def add_badge(self, badge_id):
        """
        :badge_id: (string) Id of a badge to add
        """
        
        b = get_badge(badge_id)
        if b != None:
            if b.id not in self.badges:
                self.badges.append(b.id)
                return "SUCCESS"
            say(f"[WARN] Unable to add badge (user already owns the badge)")
            return "USER ALREADY HAS BADGE"
        say(f"[WARN] Unable to add badge (badge doesn't exist)")
        return "CANNOT FIND BADGE"
        
    def remove_badge(self, badge_id):
        """
        :badge_id: (string) Id of a badge to remove
        """
        
        b = get_badge(badge_id)
        if b != None:
            if b in self.badges:
                for ub in self.badges:
                    if ub == b:
                        self.badges.remove(b.id)
                return "SUCCESS"
            say(f"[WARN] Unable to remove badge (user does not have the badge)")
            return "NOT BADGE OWNER"
        say(f"[WARN] Unable to remove badge (badge doesn't exist)")
        return "CANNOT FIND BADGE"
    
#RATELIMITS------------------------------------    
class cooldown:

    def __init__(self, name, delay):
        self.cds = {}
        self.name = name
        self.delay = delay

    def check_cooldown(self, u):
        t = u.uuid
        if t in self.cds:
            if self.cds[t] <= time.time():
                del self.cds[t]

    def has_cooldown(self, u):
        if u.permissionlvl > 900: return False
        self.check_cooldown(u)
        t = u.uuid
        if t in self.cds:
            return True
        return False

    def get_cooldown(self, u):
        self.check_cooldown(u)
        t = u.uuid
        if t in self.cds:
            return self.cds[t] - time.time()
        return None

    def put_cooldown(self, u):
        self.check_cooldown(u)

        if u.permissionlvl > 900:
            return

        t = u.uuid

        self.cds[t] = time.time() + self.delay

class upload_cooldown(cooldown):
    def __init__(self):
        self.cds = {}
        self.name = "Upload"
        self.delay = 1
        
class dashboard_cooldown(cooldown):
    def __init__(self):
        self.cds = {}
        self.name = "Dashboard"
        self.delay = 0.25

class action_cooldown(cooldown):
    def __init__(self):
        self.cds = {}
        self.name = "Action"
        self.delay = 2


class cooldowns:
    upload = upload_cooldown()
    dashboard = dashboard_cooldown()
    action = action_cooldown()
    cooldowns = [upload, dashboard, action]
#----------------------------------------------------------------


class task:
    def __init__(self):
        self.task = ""
        self.args = []
        self.output = NULL
        
class badge:
    def __init__(self):
        self.icon = ""
        self.label = ""
        self.color = ""
        self.description = ""
        self.id = ""
    

host = "0.0.0.0"

invites = json.loads(open("localstorage/invites.json", "r").read())
users = []
tasks = []
badges = []
news = json.loads(open("localstorage/news.json", "r", encoding="utf-8").read())
domains = ["xello.blue", "ketamine.top", "2u9.me", "guguhack.software", "wumpus.tech", "drifty.wtf"]

#file formats
image_formats = ["png", "jpg", "jpeg", "jfif", "gif", "svg"]
video_formats = ["mp4", "mov", "webm"]
audio_formats = ["mp3", "ogg", "wav"]
other_formats = []

allowed_file_types = image_formats+video_formats+audio_formats+other_formats

app = Flask(__name__)

#DISCORD BOT-----------
bot = commands.Bot(command_prefix="!", help_command=None, case_insensitive=True, intents = discord.Intents.all())
taskbot = commands.Bot(command_prefix="FREEDOMFUCKYEAHAAAAAAA111111111111111111111", intents = discord.Intents.all())
clr = 0xA79FFF
localhost = True if "localhost" in os.listdir(".localhost") else False

#bullshit--------------

def say(msg: str):
    print(
    f"{Fore.LIGHTBLACK_EX}[{time.strftime('%H:%M:%S', time.localtime())}] {Fore.RESET}" +  
        
        str(msg).replace(
    
              "[INFO]", f"{Fore.LIGHTBLUE_EX}[INFO]{Fore.RESET}"
    ).replace("[SHELL]", f"{Fore.LIGHTGREEN_EX}[SHELL]{Fore.RESET}"
    ).replace("[ERROR]", f"{Fore.RED}[ERROR]{Fore.RESET}"
    ).replace("[DEBUG]", f"{Fore.LIGHTMAGENTA_EX}[DEBUG]{Fore.RESET}"
    ).replace("[WARN]", f"{Fore.YELLOW}[WARN]{Fore.RESET}"
    ).replace("[XELLOBLUE]", f"{Fore.CYAN}[XELLOBLUE] {Fore.RESET}")
    
    )
    
def scripts():
    scriptbase.run()
    
def autosave():
    while True:
        ssave()
        clear_temp_data()
        if not localhost:
            update_stats()
        time.sleep(300)

def config():
    return json.loads(
        open("localstorage/config.json", "r").read()
    )
        
def execute():
    exec(
        open("localstorage/command.txt", "r", encoding="utf-8").read() )
        
def shell():
    while True:
        s = input()
        if s.startswith("!"):
            try:
                scriptbase.run(s.replace("!", "", 1))
            except Exception as error:
                say(f"[ERROR] Scriptbase: {error}")
        else:
            try:
                exec(s)
            except Exception as error: say(f"[SHELL] Error: {error}")

def find_file(file):
    for f in os.listdir("usercontent"):
        if f.startswith(file):
            return f

def clear_temp_data():
    #CONFIGS
    for f in os.listdir("files/cfg"):
        try:
            os.remove(f"files/cfg/{f}")
        except Exception as error: say(f"[WARN] CLEARCONFIG: ({f}) {error}")
    
    #2fa codes
    for u in users:
        u._2fa["code"] = ""

def save():
    start = time.time()
    say("Initialized saving process")
    save_users()
    save_invites()
    save_articles()
    say(f"Saving process finished within {(time.time()-start):.3f}s")

def ssave():
    exec("""
say("[INFO] Starting Secure-Save process")

start = time.time()
l = []
for t in users:
    members = vars(t)

    l.append(members)

s = json.dumps(l, indent=2)

f = open("localstorage/users.json", "w")
f.write(s)
f.close()

say(f"[INFO] Users saved in {(time.time()-start):.3f}s")
        
start = time.time()
    
f = open("localstorage/news.json", "w")
f.write(json.dumps(news, indent=2))
f.close()

say(f"[INFO] Articles saved in {(time.time()-start):.3f}")

start = time.time()
    
f = open("localstorage/invites.json", "w")
f.write(json.dumps(invites))
f.close()

say(f"[INFO] Invites saved in {(time.time()-start):.3f}s")

say(f"[INFO] Completed Secure-Save process")
say(f'[DEBUG] Runtime users: {len(users)}, Saved users: {len( json.loads( open("localstorage/users.json", "r").read() ) )}')
say(f'[DEBUG] Runtime invites: {len(invites)}, Saved invites: {len( open("localstorage/invites.json", "r").read().splitlines() )}')
say(f'[DEBUG] Runtime articles: {len(news)}, Saved articles: {len( json.loads( open("localstorage/news.json", "r" ).read() ) )}')
say(f"[WARN] ALWAYS CHECK THAT RUNTIME OBJECTS ARE THE SAME AS SAVED OBJECTS BEFORE QUITTING!")
""")
def load():
    load_users()
    load_badges()
    
def load_badges():
    start = time.time()
    l = json.loads(open("localstorage/badges.json", "r").read())
    for x in l:
        b = badge()
        for i in x:
            setattr(b, i, x[i])

        badges.append(b)

    say(f"[INFO] Badges loaded in {(time.time()-start):.3f}s")
    
def load_users():
    start = time.time()
    l = json.loads(open("localstorage/users.json", "r").read())
    reged = []
    for x in list(reversed(l)):
        u = user()
        for i in x:
            setattr(u, i, x[i])

        if u.uuid not in reged:
            users.append(u)

    say(f"[INFO] Users loaded in {(time.time()-start):.3f}s")
    
def save_users():
    start = time.time()
    l = []
    for t in users:
        members = vars(t)

        l.append(members)
    
    s = json.dumps(l, indent=2)
    
    f = open("localstorage/users.json", "w")
    f.write(s)
    f.close()
    
    say(f"[INFO] Users saved in {(time.time()-start):.3f}s")

def save_articles():
    start = time.time()
    
    f = open("localstorage/news.json", "w")
    f.write(json.dumps(news, indent=2))
    f.close()
    
    say(f"[INFO] Articles saved in {(time.time()-start):.3f}")

def save_invites():
    start = time.time()
        
    f = open("localstorage/invites.json", "w")
    f.write(json.dumps(invites))
    f.close()
    
    say(f"[INFO] Invites saved in {(time.time()-start):.3f}s")

def get_user(q, stype="id"):
    if stype in ["id", "uuid"]:
        for u in users:
            if u.uuid == q:
                return u
    elif stype == "username":
        for u in users:
            if u.username.lower() == q.lower():
                return u
            
    elif stype == "uid":
        for u in users:
            if str(u.uid) == str(q):
                return u
    
    elif stype == "discord":
        q = str(q)
        for u in users:
            try:
                if str(u.discord["id"]) == q:
                    return u        
            except: pass
    
    else:
        for u in users:
            if u.token == q:
                return u

def get_article(q):
    for a in news:
        if a["id"] == q:
            return a

def get_author(q):
    for u in users:
        if q in u.posts:
            return u

def get_invite(code):
    for i in invites:
        if i["code"] == code:
            return i

def create_task(t):
    tasks.append(t)

def _hash(var):
    return str(hashlib.sha256(var.encode('utf-8')).hexdigest())

def has_unicode(var: str):
    acceptable = string.ascii_letters + string.digits + "._"
    for l in var:
        if l.lower() not in acceptable: return True
    return False

def update_stats():
    say("[INFO] Requesting stats update")
    t = task()
    t.task = "UPDATE-STATS"
    create_task(t)

def get_error_message(e):
    try:
        return "{"+str(e).split(": {")[1]
    except:
        return e

def exit():
    ssave()
    say("[INFO] Runtime data saved, exiting")
    os._exit(0)

def get_embed_object(u, obj):
    if u == None:
        return obj
    
    obj = obj.replace("%user%", u.username)
    obj = obj.replace("%uid%", str(u.uid))
    obj = obj.replace("%posts%", str(len(u.posts)))
    obj = obj.replace("%uuid%", u.uuid)
    return obj

def get_extension(filename):
    extension = filename.split(".")
    return extension[(len(extension)-1)]

#BADGES
def get_badge(tb):
    for b in badges:
        if b.id.lower() == tb.lower():
            return b
#-----

#LOCKDOWN

def setlockdown(val):
    global lockdown
    lockdown = val
    say(f"[XELLOBLUE] Lockdown was set to {val}")

#--------

#CAPTCHA
def verify_recaptcha(response):
    recaptcha_response = {
        "secret": config()["RECAPTCHA.secret"],
        "response": response
    }
    response = requests.post("https://www.google.com/recaptcha/api/siteverify", data=recaptcha_response)
    if response.status_code != 200:
        return False
    
    response_text = response.json()

    return response_text["success"]
#-----------------

#STATIC PAGES
@app.route("/")
def index():
    if get_user(request.cookies.get("token"), "token") != None:
        return redirect("/dashboard")
    return render_template('index.html',
        stats_users = len(users), stats_posts = len(os.listdir("usercontent")))

@app.route("/discord")
def discord_server():
    return redirect("https://discord.gg/RKKEUj3JPQ")

@app.route("/faq")
def faq():
    return render_template('faq.html')

@app.route("/terms")
def terms():
    return render_template("tos.html")  

@app.route("/privacy")
def privacy():
    return render_template("policy.html")


#USER SECTION  

@app.route("/migrate")
def migrate():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return redirect("/login")
    
    return render_template("migration.html", invite = u.sharify_invite, sharify_login = "https://sharify.in/login")

@app.route("/api/my-files", methods = ["POST"])
def my_files():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return json.dumps({"message": "You're not logged in"}), 404
    
    files = []
    for x in u.posts:
        f = find_file(x)
        if f != None:
            files.append(f)
        
    zip_id = f"{u.username}_xelloblue-"+"".join(random.choice(string.ascii_lowercase) for _ in range(10)) + ".zip"
    z = zipfile.ZipFile("files/cfg/" + zip_id, "w")    
    for file in files:
        z.write(f"usercontent/{file}")
    
    return json.dumps({"zip": f"/cfg/{zip_id}"})

@app.route("/dashboard")
def dashboard():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return redirect("/login")

    
    #INVITES
    invs = ""
    for i in u.invite_created:
        if i["usedBy"] in ["", None]:
            invs += i["code"]+f''' <i class="fa-solid fa-copy" style="color: var(--url)" onclick="copyToClipboard('{i["code"]}');"></i>'''+"\n"
    invs = invs[:(len(invs)-1)]
    if invs == "": invs = "No invites"
    
    invited_by = u.invite_meta["createdBy"]
    if invited_by in ["", None]:
        invited_by = "System"
    else: invited_by = get_user(invited_by).username
    
    
    #GALLERY
    gallery_content = ""
    for file in list(reversed(u.posts)):
        tag = None
        if invis_char not in file:
            file_name = find_file(file)
            if file_name != None and get_extension(file_name) in image_formats:
                tag = f'<img src="/usercontent/{file_name}" id="media-{file}">'
            elif file_name != None and get_extension(file_name) in video_formats:
                tag = f'<video src="/usercontent/{file_name}" controls id="media-{file}"></video>'

            if tag != None:         
                gallery_content += f"""<div class="gallery-item" id="fileId-{file}">
                <h5>{file} <span class="text-badge">{get_extension(file_name)}</span></h5>
                {tag}
                <br>

                <span style="color: var(--url);"><i class="fa-solid fa-link" title="Copy URL" onclick="copyToClipboard('https://xello.blue/{file}'); motd('URL Copied to clipboard')"></i></span>
                <span style="color: var(--url);"><i class="fa-solid fa-up-right-from-square" title="Open" onclick="openURL('/usercontent/{file_name}')"></i></span>

                <span style="color: var(--destructive); float: right;"><i class="fa-solid fa-trash" title="Delete" onclick="deleteFile('{file}');"></i></span>
            </div>"""
        
    #DISCORD ACCOUNT
    try:
        discord_username = u.discord["username"]
        discord_tag = u.discord["discriminator"]
    except:
        discord_username = "No Account"
        discord_tag = "0000"
        
    
    #ARTICLE DIV
    a = get_article(config()["ARTICLE.pinned"])
    if a == None: a = {"title": "News", "spoiler": "Unable to load article", "id": "null"}
    
    #TAB SELECTOR
    tab = request.args.get("tab")
    if tab not in ["home", "discord", "embeds", "uploads", "gallery", "profile"]: tab = "home"
    
    #WARNINGS
    warns = ""
    for warn in config()["DASHBOARD.warning"]:
        w_id = "".join(random.choice(string.ascii_letters) for i in range(5))
        warns += f"""
            <div id="dw-{w_id}" onclick="dismissWarning('{w_id}')" title="Click to dismiss">
                <div id="dash-warn" class="warn-t{warn["level"]}">
                    <i class="fa-solid fa-{warn["icon"]}"></i> {warn["content"]}
                </div>
            </div>
        """
    
    #RENDERING
    return render_template("dashboard.html",
    dash_warns = warns, stats_uploads = len(os.listdir("usercontent")), stats_users = len(users),
    profile_uploads = len(u.posts), username = u.username, uid = u.uid, article_title = a["title"].upper(),
    article_spoiler = a["spoiler"], article_id = a["id"],
    
    invites = invs, invited_by = invited_by, 
    
    bio = u.profile["bio"],
    
    uploadkey = u.username.lower()+"."+u.token, setting_hidden_url = u.hidden_url,
    
    setting_embed_title = u.embed["title"], setting_embed_description = u.embed["description"], setting_embed_color = u.embed["color"], setting_embed = u.embed["enabled"],
    
    discord_username = discord_username, discord_tag = discord_tag,
    
    setting_domain = u.domain["domain"], setting_subdomain = u.domain["subdomain"].replace(".", ""), setting_random_domain = u.domain["random"],
    
    gallery = gallery_content, tab = tab
    )
    
@app.route("/welcome")
def welcome_dashboard():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return redirect("/login")
    
    return render_template("welcome.html",
        username = u.username
                           )


# @app.route("/gallery", methods = ["GET"])
# def gallery():
#     u = get_user(request.cookies.get("token"), "token")
#     if u != None:
#         content = ""
        
#         for file in list(reversed(u.posts)):
#             tag = None
#             file_name = find_file(file)
#             if file_name != None and get_extension(file_name) in image_formats:
#                 tag = f'<img src="/usercontent/{file_name}" id="media-{file}">'
#             elif file_name != None and get_extension(file_name) in video_formats:
#                 tag = f'<video src="/usercontent/{file_name}" controls id="media-{file}"></video>'
    
#             if tag != None:         
#                 content += f"""<div class="gallery-item" id="fileId-{file}">
#                 <h5>{file} <span class="text-badge">{get_extension(file_name)}</span></h5>
#                 {tag}
#                 <br>

#                 <span style="color: var(--url);"><i class="fa-solid fa-link" title="Copy URL" onclick="copyToClipboard('https://xello.blue/{file}')"></i></span>
#                 <span style="color: var(--url);"><i class="fa-solid fa-up-right-from-square" title="Open" onclick="openURL('/usercontent/{file_name}')"></i></span>

#                 <span style="color: var(--destructive); float: right;"><i class="fa-solid fa-trash" title="Delete" onclick="deleteFile('{file}');"></i></span>
#             </div>"""
        
#         return render_template("gallery.html", user = u.username, content = content)
    
#     return redirect("/login")

#UPLOAD

@app.route("/upload", methods = ["POST"])
def upload():
    try:
        key = request.headers.get("UploadKey")
        file = request.files["image"]
        extension = get_extension(file.filename)
        
        keylist = key.split(".")
        try: u = get_user(keylist[(len(keylist)-1)], "token")
        except: abort(500, json.dumps({"error": "Corrupted upload key"}))
        
        if u == None:
            abort(401, json.dumps({"error": "User not logged in"}))
        
        if cooldowns.upload.has_cooldown(u):
            return abort(429, json.dumps({"error": "You are being ratelimited.", "timeout": cooldowns.upload.get_cooldown(u)}))
        cooldowns.upload.put_cooldown(u)
            
        if extension not in allowed_file_types:
            abort(403, json.dumps({"error": "Unsupported file format"}))
        
        if u.domain["random"]:
            domain = random.choice(u.domain["randomDomains"])
        else:
            domain = u.domain["domain"]
        

        image_id = "".join(random.choice(string.ascii_letters) for _ in range(10))
        file.save(f"usercontent/{image_id}.{extension}") 
        u.posts.append(image_id)
        
        say(f"[XELLOBLUE] UPLOAD - Author: {u.username} - File: {image_id}.{extension} ")   
        if u.hidden_url:
            return json.dumps({"imageUrl": f"https://{u.domain['subdomain']}{domain}/usercontent/{image_id}.{extension}"})
        return json.dumps({"imageUrl": f"https://{u.domain['subdomain']}{domain}/{image_id}"})
    except Exception as err:
        say(f"[ERROR] {err}")
        return abort(500, json.dumps({"error": f"Upload error: {err}"}))

@app.route("/upload/webdashboard", methods=["POST"])
def upload_web_dashboard():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return abort(401, json.dumps({"msg": "Access denied", "success": False}))
    
    
    if cooldowns.upload.has_cooldown(u):
        return abort(429, json.dumps({"msg": "Ratelimited", "error": "You are being ratelimited.", "timeout": cooldowns.upload.get_cooldown(u)}))
    cooldowns.upload.put_cooldown(u)

    file = request.files["file"]
    extension = get_extension(file.filename)
    
    if extension not in allowed_file_types:
        return abort(403, json.dumps({"msg": "Unsupported file format", "success": False}))
    
    image_id = "".join(random.choice(string.ascii_letters) for _ in range(10))
    file.save(f"usercontent/{image_id}.{extension}") 
    u.posts.append(image_id)
    
    if u.domain["random"]:
        domain = random.choice(u.domain["randomDomains"])
    else:
        domain = u.domain["domain"]

    say(f"[XELLOBLUE] UPLOAD - Author: {u.username} - File: {image_id}.{extension} ")        
    return json.dumps({"msg": "File uploaded successfully with WDD-1", "url": f"https://{u.domain['subdomain']}{domain}/{image_id}", "success": True})

#OTHER
@app.route("/delete-file/<file>", methods = ["DELETE"])
def delete_file(file):
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        abort(401, json.dumps({"msg": "User doesn't exist"}))
    
    if file not in u.posts:
        abort(403, json.dumps({"msg": "File doesn't exist"}))
        
    u.posts.remove(file)

    file = find_file(file)
    if file == None:
        abort(403, json.dumps({"msg": "File doesn't exist"}))

    try:
        os.remove(f"usercontent/{file}")
    except:
        abort(500, json.dumps({"msg": "Failed to delete the file"}))

    return json.dumps({"msg": "File was deleted", "deletedURL": f"https://xello.blue/usercontent/{file}", "deletedFile": f"{file}"})

@app.route("/api/embed-config", methods = ["OPTIONS"])
def api_embed_config():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        abort(401, json.dumps({"msg": "User not logged in"}))
        
    
    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)
        
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["color", "title", "description"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
        
    if payload["color"] != "" and len(payload["color"]) < 10:
        u.embed["color"] = payload["color"]
    
    if len(payload["title"]) < 50:
        u.embed["title"] = payload["title"]
    
    if len(payload["description"]) < 300:
        u.embed["description"] = payload["description"]
    
    if payload["title"] == "":
        u.embed["title"] = ""
    
    return json.dumps({"msg": "Configuration saved"}) 

@app.route("/api/download-config", methods = ["GET"])
def download_config():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return abort(401, json.dumps({"msg": "User not logged in"}))
    
    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)
    
    config_id = "xelloblue-"+_hash(str(uuidgen.uuid4()))
    file = f"files/cfg/{config_id}.sxcu"
        
    cfg = open("localstorage/template.sxcu", "r", encoding="utf-8").read()
    cfg = cfg.replace("[[UPLOADKEY]]", u.username.lower()+"."+u.token)
    cfg = cfg.replace("[[DOMAIN]]", "xello.blue")
    open(file, "w", encoding="utf-8").write(cfg)
    
    return json.dumps({"msg": "Config is ready to download", "url": f"/cfg/{config_id}.sxcu"})

@app.route("/api/embed", methods = ["OPTIONS"])
def api_embed():
    status = request.args.get("status")
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return abort(401, json.dumps({"msg": "User not logged in"}))
    
    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)
    
    if status == "true":
        u.embed["enabled"] = False
        return json.dumps({"msg": "Embeds disabled"})
    u.embed["enabled"] = True
    return json.dumps({"msg": "Embeds enabled"})

@app.route("/api/hide-url", methods = ["OPTIONS"])
def api_hidden_url():
    status = request.args.get("status")
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return abort(401, json.dumps({"msg": "User not logged in"}))
    
    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)
    
    if status == "true":
        u.hidden_url = False
        return json.dumps({"msg": "URLs shown"})
    u.hidden_url = True
    return json.dumps({"msg": "URLs hidden"})

@app.route("/domain", methods=["OPTIONS"])
def domain():
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["domain", "subdomain"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
         
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        abort(401, json.dumps({"msg": "User not logged in"}))
        
    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)
        
    if payload["domain"] not in domains:
        abort(403, json.dumps({"msg": "This domain is not under xello.blue services"}))
        
    if has_unicode(payload["subdomain"]):
        abort(403, json.dumps({"msg": "Subdomain can not contain unicode characters"}))
    
    u.domain["subdomain"] = payload["subdomain"].replace(".", "")+"."
    if payload["subdomain"] in ["", ".", " ", " ."] : u.domain["subdomain"] = ""
    u.domain["domain"] = payload["domain"]
    u.domain["random"] = payload["random"]
    
    return json.dumps({"msg": "Domain changed"})

#STATUS
@app.route("/status")
def status():
    return r'<style>html, body {margin: 0; padding: 0;}</style> <iframe src="https://xello-blue.betteruptime.com/" style="width: 100vw; height: 100vh; border: none; outline: none;">'

#PROFILE
@app.route("/api/profile", methods=["POST"])
def api_profile():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return abort("401", json.dumps({"msg": "Authentication required"}))

    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)

    try:
        payload = json.loads(request.get_data().decode())
        for x in ["bio", "theme", "font", "showDiscord"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
        
    if len(payload["bio"]) > 300:
        abort(400, json.dumps({"msg": "Bio is too long"}))
        
    if str(payload["theme"]).lower() not in ["dark", "light", "wooden"]:
        abort(400, json.dumps({"msg": "Unknown theme"}))

    if str(payload["font"]).lower() not in ["ubuntu", "kanit", "rubik"]:
        abort(400, json.dumps({"msg": "Unknown font"}))
        
    if type(payload["showDiscord"]) != bool:
        abort(400, json.dumps({"msg": "Show Discord must be a boolean (true/false)"}))

    u.profile["bio"] = payload["bio"]
    u.profile["theme"] = payload["theme"]
    u.profile["font"] = payload["font"]
    u.profile["show_discord"] = payload["showDiscord"]
    return json.dumps({"msg": "Profile updated"})

@app.route("/u/editor", methods=["GET"])
def user_profile_editor():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return redirect("/login")
    
    return render_template("profile_editor.html",
        username = u.username, font = u.profile["font"], theme = u.profile["theme"],
        bio = u.profile["bio"], show_discord = u.profile["show_discord"]) 
    
@app.route("/u/preview")
def user_profile_preview():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return redirect("/login")

    r = request.args.get
    
    show_discord = ""
    if r("showDiscord") == "true":
        show_discord = """<img src="/discord.png" id="discord" onclick="alert('user#0000')" title="user#0000}">"""

    return render_template("profile_preview.html", uid=u.uid,
        username = u.username, font = r("font"), theme = r("theme"), bio = r("bio"), discord = show_discord, pfp = "/user.png")

@app.route("/u/<uid>")
def profile_loader(uid):
    u = get_user(uid, "uid")
    if u == None:
        return abort(404)
      
    return render_template("profile.html", username = u.username, theme = u.profile["theme"], font = u.profile["font"], uid = u.uid)

@app.route("/api/u/<uid>")
def api_user_profile(uid):
    u = get_user(uid, "uid")
    if u == None:
        return abort(404)
    
    viewtype = request.args.get("viewtype")
    
    if viewtype not in ["HTML", "JSON"]:
        return abort(400, json.dumps({"msg": "Disallowed viewtype"}))
        
    pfp = "https://xello.blue/user.png"
    discord_user = ""
    try:
        if u.discord != user().discord:
            t = task()
            t.task = "GET-DISCORD-ACCOUNT"
            t.args = [u.discord['id']]
            create_task(t)
            while True:
                if t.output != NULL: break
                    
            discord_user = t.output
            if discord_user != None:
                pfp = discord_user.display_avatar
    except: pass
            
    bio = u.profile["bio"]
    if bio == "": bio = "Hello! I am a user of Xello.Blue file hosting service and I am using it to store and share important documents and files."
    
    discord_element = ""
    if (u.discord not in ["", 0, None, NULL]) and u.profile["show_discord"]:
        discord_element = f"""<img src="/discord.png" id="discord" onclick="alert('{discord_user}')" title="{discord_user}">"""
    
    buttons = ""
    if u == get_user(request.cookies.get("token"), "token"):
        buttons = """<a href="/u/editor" style="font-size: 20px; margin-left: 2vw;"><i class="fa-solid fa-brush"></i></a>"""
    
    htmlbadges = ""
    for b in u.badges:
        b = get_badge(b)
        if b == None: b = get_badge("ERROR")
        htmlbadges += f"""<div class="profilebadge" id="badge-{b.id}"><i class="fa-solid fa-{b.icon}" title="{b.label}" style="color: #{b.color} !important;"></i></div>"""
    
    if viewtype == "HTML":
        return render_template("profile_api.html", htmlbadges=htmlbadges, username=u.username, buttons=buttons, discord_element=discord_element, bio=bio, pfp=pfp)
        
    if viewtype == "JSON":
        JSONDISCORDUSER = discord_user if u.profile["show_discord"] else "REDACTED"
        return json.dumps({"avatar_url": str(pfp), "theme": u.profile["theme"], "font": u.profile["font"], "bio": u.profile["bio"], "discord": str(JSONDISCORDUSER)})
    
    return ""

#ARTICLES
@app.route("/a/<article_id>")
def article(article_id):
    a = get_article(article_id)
    if a == None:
        abort(404)

    a["views"] += 1
    return render_template("article.html",
        author = get_user(a["author"]).username, title=a["title"], content=a["content"], views=a["views"], spoiler=a["spoiler"])

@app.route("/a")
def article_list():
    output = "<h1>Articles</h1><br>"
    for a in news:
        output += f'<li><a href="/a/{a["id"]}">{a["title"]}</li>'
    return output

#API

@app.route("/api/stats")
def api_stats():
    return json.dumps({"files": len(os.listdir("usercontent")), "users": len(users)})

@app.route("/u/details", methods=["OPTIONS"])
def user_details():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        abort(401, json.dumps({"msg": "Improper token was provided"}))

    bl = []
    for b in u.badges:
        bl.append(b)

    return json.dumps({"username": u.username, "uid": u.uid, "uuid": u.uuid, "discordId": u.discord, "embedSettings": u.embed, "profileSettings": u.profile, "posts": u.posts, "badges": bl})

@app.route("/my-data")
def my_data():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return json.dumps({"msg": "Log in and try again"})
    
    bl = []
    for b in u.badges:
        bl.append(b)
    
    return json.dumps({"username": u.username, "uid": u.uid, "uuid": u.uuid, "discordId": u.discord, "embedSettings": u.embed, "profileSettings": u.profile, "posts": u.posts, "badges": bl, "password": u.password})    

#AUTH

@app.route("/invite/<code>")
def register_with_invite(code):
    if get_invite(code) == None: return redirect("/register")
    return render_template("register.html", invite_code = code)

@app.route("/api/terminate", methods=["POST"])
def api_terminate():
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["password", "username"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
         
    u = get_user(request.cookies.get("token"), "token")
    
    if u == None:
        abort(401, json.dumps({"msg": "User not logged in"}))
    
    if _hash(payload["password"]) != u.password:
        abort(403, json.dumps({"msg": "Password is incorrect"}))
    
    uid = u.uid
    
    du = get_user(uid, "uid")
    print(du.username)
    
    du = user()
    du.username = "Deleted_User_"+"".join(random.choice(string.ascii_letters+string.digits) for i in range(5))
    du.password = _hash("".join(random.choice(string.ascii_letters) for i in range(10)))
    du.token = _hash("DELETEDUSER"+"".join(random.choice(string.digits) for i in range(10)))
    du.uid = uid

    users.remove(u)
    users.append(du)
    
    return json.dumps({"msg": "Account deleted"})

@app.route("/api/change-name", methods=["POST"])
def api_change_name():
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["new_username"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
        
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        abort(401, json.dumps({"msg": "User not logged in"}))
    
    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)
    
    username = payload["new_username"]
    
    if len(username) < 3 or len(username) > 20 or has_unicode(username):
        abort(403, json.dumps({"msg": "Unacceptable username, usernames must be within 3-20 characters long, and can only contain letters, numbers, dots and underscores"}))    
        
    if get_user(username, "username") != None:
        abort(403, json.dumps({"msg": "Username is taken"}))
        
    u.username = username
    return json.dumps({"msg": "Username changed"})

@app.route("/api/change-password", methods = ["POST"])
def api_change_password():
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["current_password", "new_password"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
        
    new_password = payload["new_password"]
    current_password = payload["current_password"]
    u = get_user(request.cookies.get("token"), "token")
    
    if cooldowns.action.has_cooldown(u):
        return abort(429, json.dumps({"msg": "You are being ratelimited.", "timeout": cooldowns.action.get_cooldown(u)}))
    cooldowns.action.put_cooldown(u)
    
    if u == None:
        abort(401, json.dumps({"msg": "User not logged in"}))
    
    if _hash(current_password) != u.password:
        abort(403, json.dumps({"msg": "Incorrect current password"}))
    
    if new_password == current_password:
        abort(403, json.dumps({"msg": "You can't use the same password"}))
        
    if len(new_password) < 8:
        abort(403, json.dumps({"msg": "Password is too short, make sure its at least 8 characters long"}))
    
    u.password = _hash(new_password)
    return json.dumps({"msg": "Password changed"})
    
@app.route("/api/reset-key", methods=["PUT"])
def api_resetkey():
    u = get_user(request.cookies.get("token"), "token")

    if u != None:
        u.token = _hash(str(uuidgen.uuid4()))
        return json.dumps({"msg": "API Key was changed", "token": u.token})
        
    abort(401, json.dumps({"msg": "Unable to get user by token"}))

@app.route("/register")
def register():
    return render_template('register.html')

@app.route("/api/register", methods=["POST"])
def api_register():
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["username", "password", "invite", "C-TOKEN"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
        
    username = payload["username"]
    password = payload["password"]
    invite = get_invite(payload["invite"])

    if verify_recaptcha(payload["C-TOKEN"]):
        abort(401, json.dumps({"msg": "Verification failed"}))

    if invite == None:
        abort(401, json.dumps({"msg": "Invite code is not valid"}))
        
    if invite["usedBy"] not in ["", None, NULL]:
        abort(401, json.dumps({"msg": "Invite code already in use"}))
        
    if len(username) < 3 or len(username) > 20 or has_unicode(username):
        abort(400, json.dumps({"msg": "Unacceptable username, usernames must be within 3-20 characters long, and can only contain letters, numbers, dots and underscores"}))
    
    if get_user(username, "username") != None:
        abort(401, json.dumps({"msg": "This username is already in use"}))
    
    if len(password) < 8:
        abort(400, json.dumps({"msg": "Password is too short, make sure its at least 8 characters"}))

    u = user()
    u.username = username
    u.password = _hash(password)
    u.token = _hash(str(uuidgen.uuid4()))
    u.uid = len(users)+1
    u.uuid = str(uuidgen.uuid4())
    
    invite["usedBy"] = u.uuid 
    if invite["createdBy"] not in [None, ""]:
        ui = get_user(invite["createdBy"], "uuid")
        for inv in ui.invite_created:
            inv["usedBy"] = u.uuid
    
    u.invite_meta = invite
    users.append(u)
    
    
        
    r = make_response(redirect("/welcome"))
    r.set_cookie("token", u.token)
    return r

@app.route("/login")
def login():
    if get_user(request.cookies.get("token"), "token") != None:
        return redirect("/dashboard")
    
    return render_template("login.html")

@app.route("/api/login", methods=["POST"])
def api_login():
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["username", "password"]:
            payload[x]
    except Exception as error:
        abort(500, json.dumps({"msg": "Corrupted payload"}))
    
    try:
        u = get_user(payload["username"], "username")
        if _hash(payload["password"]) == u.password:
            
            # if u._2fa["enabled"] and u._2fa["active"]:
            #     code = "".join(random.choice(string.ascii_letters) for x in range(20))
            #     u._2fa["code"] = code
                
            #     t = task()
            #     t.task = "2FA"
            #     t.args = [u, code]
            #     create_task(t)
                 
            #     return "", 204
            
            r = make_response(redirect("/dashboard"))
            r.set_cookie("token", get_user(payload["username"], "username").token)
            return r
    except:
        abort(403, json.dumps({"msg": "This user doesn't exist or the password isn't correct"}))

    abort(403, json.dumps({"msg": "This user doesn't exist or the password isn't correct"}))

@app.route("/login/2fa/<code>")
def login_2fa(code):
    for u in users:
        if u._2fa["code"] == code:
            r = make_response(redirect("/dashboard"))
            r.set_cookie("token", u.token)
            return r
    return abort(401, json.dumps({"msg": "expired code"}))
#FILES & ASSETS

@app.route("/cfg/<cfg>")
def _config(cfg):
    if cfg in os.listdir("files/cfg"):
        return send_file(f"files/cfg/{cfg}")
    return abort(404)

@app.route("/usercontent/<file>")
def usercontent(file):
    if file in os.listdir("usercontent"):
        return send_file(f"usercontent/{file}")
    return abort(404)

@app.route("/<file>")
def files(file):
    if file in os.listdir("files"):
        return send_file(f"files/{file}")
    
    filename = find_file(file)
    if filename != None:
        u = get_author(file)
        if u == None:
            return send_file(f"usercontent/{filename}")
            
        extension = get_extension(filename)
        if not u.embed["enabled"]:             
            if extension in image_formats:
                return render_template("embedded_img.html", img=filename, username = u.username, color = "#000000")
            elif extension in video_formats:
                return render_template("embedded_video.html", img=filename, username = u.username, color = "#000000")
        
        if extension in image_formats:
            return render_template("embedded_img.html", img=filename, username = u.username, description = get_embed_object(u, u.embed["description"]), title = get_embed_object(u, u.embed["title"]), color = u.embed["color"])
        elif extension in video_formats:
            return render_template("embedded_video.html", img=filename, username = u.username, description = get_embed_object(u, u.embed["description"]), title = get_embed_object(u, u.embed["title"]), color = u.embed["color"])
        return send_file(f"usercontent/{filename}")
        
    return abort(404)

#ADMIN SECTION
@app.route("/admin")
def admin_index():
    return redirect("/admin/login")

@app.route("/admin/login", methods=["GET"])
def admin_login():
    say(f"[WARN] ADMIN LOGIN PAGE WAS ACCESSED")
    return render_template("admin_login.html")

@app.route("/api/admin-login", methods = ["POST"])
def api_admin_login():
    try:
        payload = json.loads(request.get_data().decode())
        for x in ["username", "key"]:
            payload[x]
    except Exception as error:
        abort(404)

    credentials = json.loads(open(".localhost/admin-credentials.json", "r").read())

    apikey = open("localstorage/apikey", "r").read()
    if payload["key"] == apikey and payload["username"] == credentials["user"]:
        r = make_response(redirect("/admin/dashboard"))
        r.set_cookie("a-session", apikey)
        return r

    abort(404)

@app.route("/admin/dashboard")
def admin_dashboard():
    if request.cookies.get("a-session") != open("localstorage/apikey", "r").read():
        abort(404)
        
    latest_article = news[(len(news) -1)]
    pinned_article = get_article(config()["ARTICLE.pinned"])
    if latest_article == None: latest_article = {"id": "null", "title": "unable to load"}
    if pinned_article == None: pinned_article = {"id": "null", "title": "unable to load"}
    
    a_invites = ""
    for i in invites:
        if i!="": a_invites += f"{i}\n"
    
    user_list = ""
    for u in users:
        user_list += f"""
<div style="border: 1px rgb(81, 63, 83) solid;">
<h2>{u.username}</h2>
<p>UID: {u.uid} • UUID: {u.uuid}</p>
<p>Posts: {len(u.posts)}</p>
<p>Embed settings: {u.embed}</p>
<p>Profile settings: {u.profile}</p>
<p>Discord: {u.discord}</p>
</div>
        """
    
    return render_template("admin_dashboard.html",
                           
    user_amount = len(users),
    article_amount = len(news), article_latest_id = latest_article["id"], article_latest_title = latest_article["title"], article_pinned_id = pinned_article["id"], article_pinned_title = pinned_article["title"],
    invites = a_invites,
    user_list = user_list)
    
@app.route("/api/invite/generate", methods=["POST"])
def api_invite_generate():
    if request.args.get("key") != open("localstorage/apikey", "r").read():
        abort(404)
        
    aaa = {"code": str(uuidgen.uuid4()), "createdBy": None, "usedBy": None}
    invites.append(aaa)
    return json.dumps({"msg": "Invite code generated", "invite": aaa})

@app.route("/api/invite/wave", methods=["POST"])
def api_invite_wave():
    if request.args.get("key") != open("localstorage/apikey", "r").read():
        abort(404)
        
    for u in users:
        inv = {"code": str(uuidgen.uuid4()), "createdBy": u.uuid, "usedBy": None}
        u.invite_created.append(inv)
        invites.append(inv)
    
    say(f"[WARN] EVENT: Invite wave")
    return json.dumps({"msg": "Invite wave successful"})

@app.route("/upload/article", methods=["POST"])
def upload_article():
    if request.args.get("key") != open("localstorage/apikey", "r").read():
        abort(404)
        
    payload = json.loads(request.get_data().decode())
        
    if get_user(payload["authorUUID"], "uuid") == None:
        abort(401, json.dumps({"msg": "Not a user"}))
    
    article = {
        "title": payload["title"],
        "id": str(uuidgen.uuid4()),
        "author": payload["authorUUID"],
        "views": 0,

        "content": payload["content"],
        "spoiler": payload["spoiler"]
    }
    
    news.append(article)
    return json.dumps({"msg": "Article uploaded", "url": f"https://xello.blue/a/{article['id']}"})    

    
    
#ERRORS

@app.errorhandler(404)
def not_found(e):
    return render_template("404.html"), 404

@app.errorhandler(500)
def internal_error(e):
    return get_error_message(e), 500

@app.errorhandler(401)
def unauthorized(e): 
    return get_error_message(e), 401

@app.errorhandler(403)
def forbidden(e):
    return get_error_message(e), 403

@app.errorhandler(400)
def bad_request(e):
    return get_error_message(e), 400

#DISCORD BOT

@bot.event
async def on_ready():
    say("[INFO] Loaded discord bot")

@bot.event
async def on_message(msg):
    if not localhost:
        await bot.process_commands(msg)
        return
    
    for w in msg.content.split(" "):
        if w.lower() in profanities:
            u = get_user(msg.author.id, "discord")
            if u != None and u.permissionlvl > 750:
                pass
            else:
                await msg.channel.send(embed=discord.Embed(title="Xello.Blue", description=f"{msg.author.mention} You aren't allowed to swear", color=0xff0000))
                await msg.delete()
            break
    
    try:
        if get_user(msg.author.id, "discord").permissionlvl > 900:
            await bot.process_commands(msg)
    except: pass

@bot.event
async def on_command_error(ctx, error):
    await ctx.reply(embed=discord.Embed(title="Failed to execute the command", description=f"```css\n{error}```", color=0xff0000))

@bot.command(name="stats") #stats
async def command_stats(ctx, user: discord.User = None):
    if user == None:
        user = ctx.author
    
    u = get_user(user.id, "discord")
    if u == None:
        await ctx.reply(embed=discord.Embed(title="Stats", description="Please link your discord account [here](<https://xello.blue/dashboard?tab=discord>) to view your statistics", color=clr))
        return

    embed = discord.Embed(title="Statistics", color=clr)
    embed.set_author(name=u.username, icon_url=user.display_avatar, url=f"https://xello.blue/u/{u.uid}")
    embed.description = f"""**🔢 UID** {u.uid}\n**🖼️ Posts** {len(u.posts)}"""
    await ctx.reply(embed=embed)
    
@bot.command(name="id") #id
async def command_id(ctx):
    await ctx.reply(embed=discord.Embed(title="Your Account ID", description=f"`{ctx.author.id}`", color=clr))
    
# @bot.command(name="leaderboard") #leaderboard
# async def command_leaderboard(ctx):
#     print("not yet")
#     #make post leaderboard
    
@bot.command(name="unlink") #unlink
async def command_unlink(ctx):
    u = get_user(ctx.author.id, "discord")
    if u == None:
        await ctx.reply(embed=discord.Embed(title="Unlink", description="You don't have an account linked to your discord", color=clr))
        return
    
    u.discord = user().discord
    await ctx.reply(embed=discord.Embed(title="Unlink", description="Your account was unlinked!", color=0x00ff00).set_footer(text="Notice: If you had 2fa enabled, it is now inactive. To re-enable it you will need to re-link your account"))
    
@bot.command(name="dashboard") #dashboard
async def command_dashboard(ctx):
    await ctx.reply(embed=discord.Embed(description="[Click to open the dashboard](<https://xello.blue/dashboard>)", color=clr))

@bot.command(name="admin") #admin commands
async def command_admin(ctx, sub=None, arg1=None, arg2=None, arg3=None):
    u = get_user(ctx.author.id, "discord")
    if u == None:
        await ctx.reply(embed=discord.Embed(title="Administration", description="Link an account to proceed", color=clr))
        return
    
    if u.permissionlvl < 900:
        await ctx.reply(embed=discord.Embed(title="Administration", description="You aren't allow to execute admin commands", color=0xff0000))
        return
    
    if sub == None:
        await ctx.reply(embed=discord.Embed(title="Administration", description="Try using `!admin help`", color=clr))
        return
    
    say(f"[WARN] [XELLOBLUE] {ctx.author} executed '!admin {sub} {arg1} {arg2} {arg3}'")
    sub = sub.lower()
    if sub in ["help", "commands"]:
        await ctx.reply(embed=discord.Embed(title="Admin Commands", description="""
`!admin help` *This page*
`!admin about <search type: username/uuid/discord/token> <value>` *Get information about specified user*
`!admin invitewave [-s]` *Sends out an invite wave (-s = silent, won't be announced)* 
`!admin badge <add/del> <user: username only> <badge id>` *Adds or removes a badge from a user*
`!admin dashboard` *Sends a link to admin dashboard*
""", color=clr))
    if sub in ["about", "whos", "whois"]:
        if arg1 == None or arg2 == None:
            await ctx.reply("Invalid arguments")
            return
        ua = get_user(arg2, arg1)
        if ua == None:
            await ctx.reply(embed=discord.Embed(title="Admin About", description="User not found", color=0xff0000))
            return
        await ctx.author.send(embed=discord.Embed(title=f"About {ua.username}", description=f"||```ini\n[UID] {ua.uid}\n[UUID] {ua.uuid}\n[POSTS] {len(ua.posts)}\n[BADGES] {ua.badges}\n[DOMAIN SETTINGS] {ua.domain}\n[EMBED SETTINGS] {ua.embed}\n[BIO SETTINGS] {ua.profile}\n[PERMISSION LEVEL] {ua.permissionlvl}\n[INVITE META] {ua.invite_meta}```||", color=clr))
        await ctx.reply(f"Information about {ua.username} was sent to direct messages")
        
    if sub in ["invitewave", "wave"]:
        for ut in users:
            inv = {"code": str(uuidgen.uuid4()), "createdBy": ut.uuid, "usedBy": None}
            ut.invite_created.append(inv)
            invites.append(inv)
    
        say(f"[WARN] EVENT: Invite wave")
        await ctx.reply(embed=discord.Embed(title="Invite wave", description="Gave out everyone invites!", color=0x00ff00))
        if arg1 != "-s":
            await bot.get_channel(1055473883047800884).send("<@&1055472265506062346>", embed=discord.Embed(title="Invite Wave", description="Everyone received an invite! You can view your invites [here](<https://xello.blue/dashboard>). You can give them to a friend or whoever you want :wink:", color=clr))

    if sub in ["badge"]:
        if arg1 == None or arg2 == None or arg3 == None:
            await ctx.reply("Invalid arguments")
            return
        
        ua = get_user(arg2, "username")
        if u == None:
            await ctx.reply(embed=discord.Embed(title="Admin Badge", description="User not found", color=0xff0000))
            return
        
        b = get_badge(arg3)
        if b == None:
            await ctx.reply(embed=discord.Embed(title="Admin Badge", description="Badge doesn't exist, you can find the badge list [here](<https://github.com/Xello-Blue/xello-blue/tree/main/badges>)", color=0xff0000))
        
        if arg1 in ["add"]:
            ua.add_badge(b.id)
            await ctx.reply(embed=discord.Embed(title="Badge ADD", description=f"{b.label} badge was added to [{ua.username}](<https://xello.blue/u/{ua.uid}>)"))
        elif arg1 in ["remove", "del", "delete"]:
            ua.remove_badge(b.id)
            await ctx.reply(embed=discord.Embed(title="Badge DEL", description=f"{b.label} badge was taken away from [{ua.username}](<https://xello.blue/u/{ua.uid}>)"))
        else:
            await ctx.reply("Disallowed action (not add/del)")

    if sub in ["dash", "dashboard"]:
        await ctx.reply(embed=discord.Embed(description="[click to open](<https://xello.blue/admin/dashboard>)", color=clr))

#CUSTOM PAGES

@app.route("/sudo")
def sudo():
    return send_file("sudan/index.html")

@app.route("/sudo/<file>")
def sudo_file(file):
    return send_file("sudan/"+file)

#DISCORD OAUTH2

@app.route("/oauth2/discord/cancel", methods=["DELETE"])
def verify_cancel():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        abort(401, json.dumps({"msg": "Log-in to verify"}))
        
    if u.discord == user().discord:
        abort(403, json.dumps({"msg": "No discord account is connected"}))
        
    u.discord = user().discord
    u.remove_badge("VERIFIED")
    u._2fa["active"] = False
    return json.dumps({"msg": "success", "notice": ["2 Factor Authentication was disabled"]})

@app.route("/oauth2/discord/callback")
def discord_callback():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        abort(401, json.dumps({"msg": "Unauthorized"}))
        
    
    code = request.args.get("code")

    # Use the authorization code to exchange for an access token
    headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    }
    redirectURI = "http://localhost/oauth2/discord/callback" if localhost else "https://xello.blue/oauth2/discord/callback" 
    data = {
        "client_id": config()["DISCORD_OAUTH2.client_id"],
        "client_secret": config()["DISCORD_OAUTH2.client_secret"],
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": redirectURI,
        "scope": "identify guilds email guilds.join"
    }
    response = requests.post("https://discord.com/api/oauth2/token", headers=headers, data=data)

    # Check if the request was successful
    if response.status_code == 200:
        # Get the JSON data from the response
        data = response.json()
        # Get the access token from the data
        access_token = data["access_token"]
        
        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        response = requests.get("https://discord.com/api/users/@me", headers=headers)

        if response.status_code == 200:
            # Get the JSON data from the response
            data = response.json()
            print(data)
            # Get the desired information from the data, such as the username and discriminator
            email = None
            try:
                email = data["email"]
            except: pass
            u.discord = {"id": data["id"], "username": data["username"], "discriminator": data["discriminator"], "email": email, }

            response = joindiscord(access_token, data["id"])
            if response.status_code in [200, 201, 202, 203, 204]:
                u._2fa["active"] = True
                return redirect("/dashboard?tab=discord")
            else:
                return redirect("/dashboard")
            
        else:
            return "Failed to fetch account data", 500

    else:
        #print(response.content)
        return "An error occurred while exchanging the authorization code for an access token.", 500

@app.route("/oauth2/discord/verify", methods=["POST"])
def verify_discord():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return abort(401, json.dumps({"msg": "Unauthorized"}))
        
    if u.discord == user().discord:
        return abort(403, json.dumps({"msg": "Link your account before verifying"}))
        
    t = task()
    t.task = "VERIFY-DISCORD-ACCOUNT"
    t.args = [u.discord["id"]]
    create_task(t)
    
    while True:
        if t.output != NULL: break
        
    if t.output:
        u.add_badge("VERIFIED")
        return "", 204
    
    return json.dumps({"msg": "Unknown verification error"}), 500

@app.route("/oauth2/discord/link")
def link_discord():
    u = get_user(request.cookies.get("token"), "token")
    if u == None:
        return redirect("/login")
    
    authURL = "https://discord.com/api/oauth2/authorize?client_id=938808513164107918&redirect_uri=https%3A%2F%2Fxello.blue%2Foauth2%2Fdiscord%2Fcallback&response_type=code&scope=guilds.join%20email%20identify"
    if localhost:
        authURL = "https://discord.com/api/oauth2/authorize?client_id=938808513164107918&redirect_uri=http%3A%2F%2Flocalhost%2Foauth2%2Fdiscord%2Fcallback&response_type=code&scope=identify%20guilds%20email%20guilds.join"
    
    return redirect(authURL)

#OAUTH2 - LOGIN WITH DISCORD

@app.route("/login/discord")
def discord_login():
    if localhost:
        return redirect("https://discord.com/api/oauth2/authorize?client_id=938808513164107918&redirect_uri=http%3A%2F%2Flocalhost%2Foauth2%2Fdiscord%2Flogin&response_type=code&scope=identify")
    return redirect("https://discord.com/api/oauth2/authorize?client_id=938808513164107918&redirect_uri=https%3A%2F%2Fxello.blue%2Foauth2%2Fdiscord%2Flogin&response_type=code&scope=identify%20guilds.join%20email")

@app.route("/oauth2/discord/login")
def oauth2_discord_login():    
    code = request.args.get("code")

    # Use the authorization code to exchange for an access token
    headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    }
    redirectURI = "http://localhost/oauth2/discord/login" if localhost else "https://xello.blue/oauth2/discord/login" 
    data = {
        "client_id": config()["DISCORD_OAUTH2.client_id"],
        "client_secret": config()["DISCORD_OAUTH2.client_secret"],
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": redirectURI,
        "scope": "identify"
    }
    response = requests.post("https://discord.com/api/oauth2/token", headers=headers, data=data)

    # Check if the request was successful
    if response.status_code == 200:
        # Get the JSON data from the response
        data = response.json()
        # Get the access token from the data
        access_token = data["access_token"]
        
        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        response = requests.get("https://discord.com/api/users/@me", headers=headers)

        if response.status_code == 200:
            data = response.json()
            u = get_user(data["id"], "discord")
            if u == None:
                return render_template("msg.html", msg="Failed to authenticate, connect your discord to your account to access this feature.", redirect="/login")
            
            r = make_response(redirect("/dashboard"))
            r.set_cookie("token", u.token)
            return r
            
            
            
        else:
            return "Failed to fetch account data", 500

    else:
        #print(response.content)
        return "An error occurred while exchanging the authorization code for an access token.", 500

#OAUTH2 ACTIONS

def joindiscord(token, id):
    say(f"[INFO] joining users")
    url = f"https://discord.com/api/guilds/1055472203753328701/members/{id}"

    headers = {
        "Authorization" : f"Bot {bot_token}",
        'Content-Type': 'application/json'
    }
    
    data = {
        "access_token" : token
    }

    r = requests.put(url=url, headers=headers, json=data)
    return r


#DISCORD TASKBOT

async def process_task(task):
    match task.task:
        case "GET-DISCORD-ACCOUNT":
            u = await taskbot.fetch_user(task.args[0])
            return u
        
        case "VERIFY-DISCORD-ACCOUNT":
            try:
                guild = taskbot.get_guild(1055472203753328701)
                member = None
                for m in guild.members:
                    if int(m.id) == int(task.args[0]): member = m
                    
                role = discord.utils.get(guild.roles, name="User")
                await member.add_roles(role)
            except Exception as err:
                say(f"[ERROR] DISCORD VERIFICATION: {err}")
                return False
            return True
            
        case "UPDATE-STATS":
            say(f"[INFO] Updating stats")
            c_users = taskbot.get_channel(1068929935013589032)
            c_files = taskbot.get_channel(1068930053846605884)
            c_domains = taskbot.get_channel(1068930299343409162)

            await c_users.edit(name=f"Users: {len(users)}")
            await c_files.edit(name=f"Files: {len(os.listdir('usercontent'))}")
            await c_domains.edit(name=f"Domains: {len(domains)}")
            say("[INFO] Stats updated")
            return True
        
        case "2FA":
            try:
                du = await taskbot.fetch_user(task.args[0].discord["id"])
                embed = discord.Embed(title="Xello.Blue", description="2 Factor Authentication", color=clr)
                embed.add_field(name="Login", value=f"[Click here](<https://xello.blue/login/2fa/{task.args[1]}>) to login")
                embed.add_field(name="Wasn't you?", value="Change your password immediately [here](<https://xello.blue/dashboard?tab=profile>)")
                await du.send(embed=embed)
                return True
            except Exception as err:
                say(f"[ERROR] 2FA-TASK: {err}")
                return False
                
async def run_tasks():
    for task in tasks:
        try:
            t = await process_task(task)
            task.output = t
        except: task.output = None
        
        tasks.remove(task)

@taskbot.event
async def on_ready():
    say("[INFO] Taskbot loaded") 
    while True:
        await run_tasks()    
        await asyncio.sleep(0.3)

#THREADS---------------------

def discord_taskprocessor():
    asyncio.run_coroutine_threadsafe(taskbot.run(bot_token))

def discord_bot():
    asyncio.run_coroutine_threadsafe(bot.run(bot_token))

bot_token = config()["DISCORDBOT.token"]


load()
threading.Thread(target=discord_bot).start()
threading.Thread(target=discord_taskprocessor).start()
threading.Thread(target=autosave).start()
threading.Thread(target=shell).start()
app.run(host, port=80, debug=localhost)
